classdef (StrictDefaults) staticDetectionFuser < matlab.System
    %staticDetectionFuser Static fusion of synchronous sensor detections
    %   fuser = staticDetectionFuser creates a default 3-sensor static detection
    %   fuser with the ability to fuse angle-only detections sensors.
    %
    %   fuser = staticDetectionFuser('Name','Value') returns a staticDetectionFuser
    %   object with its properties specified as name-value pair arguments.
    %   Unspecified properties have default values. See the list of
    %   properties below.
    %
    %   step method syntax:
    %   compositeDets = step(fuser, detections)
    %
    %   [compositeDets, analysisInfo] = step(..) also provides a struct of
    %   analysis information
    %
    %   detections is cell array of objectDetection objects from all the
    %   sensors.
    %
    %   compositeDets is a cell array of objectDetection objects which are
    %   generated by fusion of most likely detections from each sensor.
    %
    %   analysisInfo is a struct with the following fields:
    %
    %   CostMatrix  - An N-Dimensional cost matrix providing the cost of
    %                 association of detections, where N is the number of
    %                 sensors. The cost is the negative log-likelihood of
    %                 the association and can be interpreted as the
    %                 negative score of the track that will be generated by
    %                 the fused measurement.
    %
    %   Assignments - A P-by-N list of assignments found, where P is the
    %                 number of composite detections
    %
    %   FalseAlarms - A Q-by-1 list of indices of detections declared as
    %                 false alarms by association
    %
    %   The step method does the following:
    %   1. Calculates the cost of fusing or matching detections from each
    %      sensor to one another.
    %   2. Solves a 2-D or S-D assignment problem, where S is the number of
    %      sensors, to associate or match detections from one
    %      sensor to others.
    %   3. Fuses the measurement and measurement covariance of the
    %      associated detection tuples to generate a list of composite or
    %      fused detections.
    %   4. Unassigned detections from each sensor are declared as false
    %      alarms.
    %
    %   Notes:
    %   1. staticDetectionFuser assumes that all sensors are synchronous 
    %      and generate detections at the same time.
    %   2. staticDetectionFuser assumes that the sensors share a common
    %      surveillance region and association of n detections out of m
    %      sensors indicates m - n miss detections or false alarms.
    %
    %   System objects may be called directly like a function instead of
    %   using the step method. For example, y = step(obj) and y = obj() are
    %   equivalent.
    %
    %   staticDetectionFuser properties:
    %
    %   FusedSensorIndex        - SensorIndex of composite detections
    %   MeasurementFusionFcn    - Function to fuse sensor detections
    %   MeasurementFormat       - Format of the fused measurement
    %   MeasurementFcn          - Measurement function for 'Custom'
    %                             MeasurementFormat
    %   MaxNumSensors           - Maximum number of sensors in the
    %                             surveillance region
    %   Volume                  - Volumes of the sensors' detection bins
    %   DetectionProbability    - Probabilities of a target detection
    %   FalseAlarmRate          - Rate of false positives generated by
    %                             sensors
    %   UseParallel             - Option to use parallel computing
    %                             resources
    %   TimeTolerance           - Absolute tolerance between time stamps of
    %                             detections
    %
    %   staticDetectionFuser methods:
    %   step      - Fuse detections from multiple sensors
    %   release   - Allow property value and input characteristics changes
    %   clone     - Create staticDetectionFuser object with same property values
    %   isLocked  - Locked status (logical)
    %   reset     - reset the properties of staticDetectionFuser object
    %
    %   Example: Fuse angle-only detections from 3 ESM sensors.
    %
    %   % Load detections from the sensors stored in a MAT file
    %   load('angleOnlyDetectionFusion.mat','detections');
    %
    %   % Visualize angle-only detections
    %   % range for plotting the direction vector
    %   rPlot = 5000;
    %   plotData = zeros(3,numel(detections)*3);
    %   for i = 1:numel(detections)
    %       az = detections{i}.Measurement(1);
    %       el = detections{i}.Measurement(2);
    %       [xt,yt,zt] = sph2cart(deg2rad(az),deg2rad(el),rPlot);
    %       % The sensor is co-located at platform center, therefore use
    %       % the position from the second measurement parameter
    %       originPos = detections{i}.MeasurementParameters(2).OriginPosition;
    %       positionData(:,i) = originPos(:);
    %       plotData(:,3*i-2) = [xt;yt;zt] + originPos(:);
    %       plotData(:,3*i-1) = originPos(:);
    %       plotData(:,3*i) = [NaN;NaN;NaN];
    %   end
    %   plot3(plotData(1,:),plotData(2,:),plotData(3,:),'r-');
    %   hold on
    %   plot3(positionData(1,:),positionData(2,:),positionData(3,:),'o','MarkerSize',12,'MarkerFaceColor','g');
    %
    %   % Create a staticDetectionFuser to fuse angle-only detections using the
    %   % MeasurementFusionFcn 'triangulateLOS'
    %   fuser = staticDetectionFuser('MeasurementFusionFcn','triangulateLOS','MaxNumSensors',3)
    %
    %   [fusedDetections, analysisInfo] = fuser(detections);
    %   fusedPositions = zeros(3,numel(fusedDetections));
    %   for i = 1:numel(fusedDetections)
    %       fusedPositions(:,i) = fusedDetections{i}.Measurement;
    %   end
    %   plot3(fusedPositions(1,:),fusedPositions(2,:),fusedPositions(3,:),'ko','MarkerSize',12, 'MarkerFaceColor','k');
    %   legend('Angle-only Detections','Sensor Positions', 'Fused Target Measurements');
    %   title('Angle-only Detection Fusion'); xlabel('x [m]'); ylabel('y [m]')
    %   view(2);
    %
    %   % Use the analysisInfo output to check the Assignments
    %   analysisInfo.Assignments
    %
    %   See also: objectDetection, triangulateLOS
    
    %   Copyright 2018-2021 The MathWorks, Inc.
    
    
    %#codegen
    properties (Nontunable)
        %MeasurementFusionFcn Function to fuse sensor detections
        %   Specify the function for fusing multiple detections as a
        %   function_handle, char array or string. The function fuses
        %   combinations of at most one detection from each sensor and
        %   returns the fused measurement and measurement noise.
        %
        %   [fusedMeasurement,fusedMeasurementNoise] = MEASUREMENTFUSIONFCN(detections)
        %
        %   fusedMeas       - a Nx1 vector of fused measurement
        %   fusedMeasNoise  - a NxN matrix of fused measurement noise
        %   detections      - a cell array of objectDetection objects
        %
        %   N can have the following values based on MeasurementFormat.
        %
        %   MeasurementFormat       | Allowed values 
        %   ------------------------+----------------
        %   Position                | 1, 2 and 3
        %   Velocity                | 1, 2 and 3
        %   PositionAndVelocity     | 2, 4 and 6
        %   Custom                  | any
        %
        %   When the input detections to the FusionFcn has a length less
        %   than NumSensors, it refers to a fused measurement from a target 
        %   which is not detected by the sensor missing from the input. 
        %   
        %   See also: objectDetection, triangulateLOS
        %
        %   Default: 'triangulateLOS'
        %   <a href = "matlab:edit('triangulateLOS')">Open triangulateLOS for more details.</a>
        MeasurementFusionFcn = 'triangulateLOS'
        
        % MeasurementFormat Format of the fused measurement
        %   Specify the format of the fused measurement as one of the
        %   [{'Position'},|'Velocity'|'PositionAndVelocity'|'Custom'].
        %
        %   'Position' format refers that the fused measurement is the
        %   position of the target in global coordinate frame.
        %
        %   'Velocity' format refers that the fused measurement is the
        %   velocity of the target in global coordinate frame.
        %
        %   'PositionAndVelocity' format refers that the fused measurement is
        %   the position and velocity of the target in global coordinate
        %   frame defined according to constant velocity state format
        %   defined as: [x;vx;y;vy;z;vz]
        %
        %   'Custom' allows you to define a custom type of measurement.
        %   You must specify the MeasurementFcn to use this format.
        %
        %   Default - 'Position'
        MeasurementFormat = 'Position';
   
        % MeasurementFcn Measurement function for 'custom' MeasurementFormat.
        %   Specify the function name for the measurement function to
        %   transform fused measurements to sensor measurements. This
        %   function is only used if MeasurementFormat is set to 'Custom'.
        %   The function must have the following signature:
        %   sensorMeas = MeasurementFcn(fusedMeas,measParameters)
        MeasurementFcn
    
        % MaxNumSensors Maximum number of sensors in the surveillance region
        %   Specify the maximum number of sensors in the surveillance
        %   region using a scalar value greater than 1.
        %
        %   Default - 3
        MaxNumSensors (1, 1) {mustBePositive, mustBeInteger, mustBeNonsparse} = 3;
        
        %FusedSensorIndex SensorIndex of the composite detections
        %   Specify the SensorIndex of the composite detections reported by
        %   the staticDetectionFuser. This is used as the SensorIndex of
        %   the objectDetection objects returned in the output
        %
        %   Default - 1
        FusedSensorIndex (1, 1) {mustBePositive, mustBeInteger, mustBeNonsparse} = 1;
    end
    
    properties (Dependent, Nontunable)
        %DetectionProbability Probabilities of a target detection
        %   Specify the probability of detection of a target by each sensor
        %   as a scalar in the range (0,1). The DetectionProbability
        %   can be specified as a scalar or a vector of n-elements, where n
        %   is the number of sensors. If specified as a scalar, each sensor
        %   is assigned the same detection probability. The probability of
        %   detection is used in calculating the cost of fusing a one
        %   (target was detected) or zero (target was not detected)
        %   detections from each sensor.
        %
        %   Default - 0.9;
        DetectionProbability;
        
        %Volume Volume of the sensors' detection bin
        %   Specify the volume of each sensor's detection bin as positive
        %   scalar. The Volume can be specified as a scalar or a vector of
        %   n-elements, where n is the number of sensors. If specified as
        %   a scalar, each sensor is assigned the same volume. For example,
        %   if a sensor produces an angle-only measurement, which includes
        %   azimuth and elevation, the volume is defined as the solid angle
        %   subtended by one bin (single detector).
        %
        %   Default - 1e-2;
        Volume;
        
        %FalseAlarmRate - Rate of false positives generated by sensors
        %   Specify the rate at which false positives are reported by
        %   sensor in each bin. The FalseAlarmRate is used to calculate the
        %   likelihood of clutter in the detections reported by each
        %   sensor. FalseAlarmRate can be specified as a positive scalar or
        %   a vector of n-elements, where n is the number of sensors. If
        %   specified as a scalar, each sensor is assumed to report false
        %   alarms at the same rate.
        %
        %   Default - 1e-6
        FalseAlarmRate;
    end
    
    properties(Nontunable)
        % UseParallel Option to use parallel computing resources
        %   The staticDetectionFuser calculates the cost of fusing
        %   detections from each sensor as an n-D assignment problem. The
        %   fuser spends most of the time in computing the cost matrix for
        %   the assignment problem. If Parallel Computing Toolbox is
        %   installed, this flag controls if the fuser can utilize the
        %   parallel pool of workers to compute the cost matrix.
        %
        %   Default - false
        UseParallel (1, 1) logical = false;
    end
    
    properties (Dependent, Nontunable)
        %TimeTolerance Absolute tolerance between time stamps of detections
        %   The staticDetectionFuser assumes that sensors are synchronous.
        %   This property defines the allowed tolerance value between
        %   detection time-stamps.
        %   
        %   Default - 1e-6
        TimeTolerance
    end
    
    properties(Hidden,Constant)
        MeasurementFormatSet = matlab.system.StringSet({'Position','Velocity','PositionAndVelocity','Custom'});
    end
    
    properties(Nontunable, Access = private)
        pStateSize
        pDataType
        p2DAssignmentFcn
        pSDAssignmentFcn
        pMeasurementFcn
        pMeasurementFusionFcn
        pTimeTolerance = 1e-6;
        pUseParallel = false;
    end
    
    properties(Access = private)
        pSampleBuffer;
    end
    
    properties(Access = private)
        pDetectionProbability;
        pVolume;
        pFalseAlarmRate;
        pDetectionTime = 0;
    end
    
    properties(Access = private)
        pFusedMeasParam
    end
   
    % Pre-computed constants
    properties(Access = private,Constant)
        constDetectionProbability = 0.9;
        constFalseAlarmRate = 1e-6;
        constVolume = 1e-2;
        constDataType = 'double';
    end
    
    methods (Access = public)
        function fuser = staticDetectionFuser(varargin)
            senIndex = fusion.internal.findProp('MaxNumSensors',varargin{:});
            argOut = {varargin{1:senIndex-1},varargin{senIndex+2:end}};
            coder.extrinsic('fusion.internal.canUsePCT');
            % Set MaxNumSensors first
            if senIndex <= numel(varargin) - 1
                fuser.MaxNumSensors = varargin{senIndex+1};
            end
            setProperties(fuser,numel(argOut),argOut{1:end});
            if ~coder.internal.is_defined(fuser.pVolume)
                fuser.Volume = fuser.constVolume;
            end
            if ~coder.internal.is_defined(fuser.pFalseAlarmRate)
                fuser.FalseAlarmRate = fuser.constFalseAlarmRate;
            end
            if ~coder.internal.is_defined(fuser.pDetectionProbability)
                fuser.DetectionProbability = fuser.constDetectionProbability;
            end
            fuser.pUseParallel = fuser.UseParallel && coder.const(fusion.internal.canUsePCT);
        end
    end
    
    methods
        function set.MeasurementFusionFcn(fuser,val)
            validateattributes(val,{'function_handle','string','char'},{'nonempty'},'staticDetectionFuser','MeasurementFusionFcn');
            fuser.MeasurementFusionFcn = val;
        end
        
        function set.FalseAlarmRate(fuser,val)
            validateattributes(val,{'single','double'},{'nonsparse','real','finite','positive','<',1},'staticDetectionFuser','FalseAlarmRate');
            coder.internal.errorIf(~any(numel(val) == [1 fuser.MaxNumSensors]),'fusion:staticDetectionFuser:expectedScalarOrMaxSensors','FalseAlarmRate',fuser.MaxNumSensors);
            if ~coder.internal.is_defined(fuser.pDataType)
                fuser.pDataType = class(val);
            end
            if ~coder.internal.is_defined(fuser.pFalseAlarmRate)
                fuser.pFalseAlarmRate = fuser.constFalseAlarmRate*ones(fuser.MaxNumSensors,1,fuser.pDataType);
            end
            fuser.pFalseAlarmRate(:) = val;
        end
        
        function set.Volume(fuser,val)
            validateattributes(val,{'single','double'},{'nonsparse','real','finite','positive'},'staticDetectionFuser','Volume');
            coder.internal.errorIf(~any(numel(val) == [1 fuser.MaxNumSensors]),'fusion:staticDetectionFuser:expectedScalarOrMaxSensors','Volume',fuser.MaxNumSensors);
            if ~coder.internal.is_defined(fuser.pDataType)
                fuser.pDataType = class(val);
            end
            if ~coder.internal.is_defined(fuser.pVolume)
                fuser.pVolume = fuser.constVolume*ones(fuser.MaxNumSensors,1,fuser.pDataType);
            end
            fuser.pVolume(:) = val;
        end
        
        function set.DetectionProbability(fuser,val)
            validateattributes(val,{'single','double'},{'nonsparse','real','finite','positive','<',1},'staticDetectionFuser','DetectionProbability');
            coder.internal.errorIf(~any(numel(val) == [1 fuser.MaxNumSensors]),'fusion:staticDetectionFuser:expectedScalarOrMaxSensors','DetectionProbability',fuser.MaxNumSensors);
            if ~coder.internal.is_defined(fuser.pDataType)
                fuser.pDataType = class(val);
            end
            if ~coder.internal.is_defined(fuser.pDetectionProbability)
                fuser.pDetectionProbability = fuser.constDetectionProbability*ones(fuser.MaxNumSensors,1,fuser.pDataType);
            end
            fuser.pDetectionProbability(:) = val;
        end
        
        function val = get.FalseAlarmRate(fuser)
            val = fuser.pFalseAlarmRate;
        end
        
        function val = get.Volume(fuser)
            val = fuser.pVolume;
        end
        
        function val = get.DetectionProbability(fuser)
            val = fuser.pDetectionProbability;
        end
        
        function set.TimeTolerance(fuser,val)
            validateattributes(val,{'single','double'},{'nonsparse','real','finite','scalar','positive'},'detectionFuser','TimeTolerance');
            fuser.pTimeTolerance = val;
        end
        
        function val = get.TimeTolerance(fuser)
            val = fuser.pTimeTolerance;
        end        
    end
    
    methods(Access = protected)
        function setupImpl(fuser,detections)
            % setupImpl - Initialize properties based on the inputs.
            fuser.p2DAssignmentFcn = @(x)fusion.internal.assignment.assign2DRelaxed(x,@assignjv);
            fuser.pSDAssignmentFcn = @(x)assignsd(x,0.05,200,'auction');
            
            sampleBuffer = getBufferFromInput(fuser,detections);
            
            % setupImpl is called everytime the inputs change. The
            % pSampleBuffer must be defined only once. pSampleBuffer helps
            % deduce the type of detection each sensor is expected to have.
            % This is required because we need to form a heterogeneous array
            % of detections.
            if coder.target('MATLAB')
                fuser.pSampleBuffer = sampleBuffer;
            elseif ~coder.internal.is_defined(fuser.pSampleBuffer)
                fuser.pSampleBuffer = cell(fuser.MaxNumSensors,1);
                for i = 1:fuser.MaxNumSensors
                    fuser.pSampleBuffer{i} = sampleBuffer{i};
                end
            end
            
            state = fuser.pMeasurementFusionFcn(sampleBuffer);
            
            if strcmpi(fuser.MeasurementFormat,'Position') || strcmpi(fuser.MeasurementFormat,'Velocity')
                coder.internal.errorIf(all(numel(state)~=[1 2 3]),'fusion:staticDetectionFuser:expectedNumMeasElements',3);
            elseif strcmpi(fuser.MeasurementFormat,'PositionAndVelocity')
                coder.internal.errorIf(all(numel(state)~=[1 2 3]),'fusion:staticDetectionFuser:expectedNumMeasElements',6);
            end
            
            fuser.pStateSize = numel(state);
            if coder.internal.is_defined(fuser.pDataType)
                fuser.pDataType = class(state);
            end
            
            fuser.pFusedMeasParam = struct('Frame','Rectangular',...
                'HasRange',true,'HasAzimuth',true,'HasElevation',true,...
                'HasVelocity',false,'IsParentToChild',false,...
                'OriginPosition',zeros(3,1,fuser.pDataType),'Orientation',eye(3,fuser.pDataType),...
                'OriginVelocity',zeros(3,1,fuser.pDataType));
        end
        
        function validatePropertiesImpl(fuser)
            if isa(fuser.MeasurementFusionFcn, 'function_handle')
                fuser.pMeasurementFusionFcn = fuser.MeasurementFusionFcn;
            else
                fuser.pMeasurementFusionFcn = str2func(fuser.MeasurementFusionFcn);
            end
            if strcmpi(fuser.MeasurementFormat,'Custom')
                validateattributes(fuser.MeasurementFcn,{'string','char','function_handle'},{'nonempty'},'staticDetectionFuser','MeasurementFcn')
                if isa(fuser.MeasurementFcn, 'function_handle')
                    fuser.pMeasurementFcn = fuser.MeasurementFcn;
                else
                    fuser.pMeasurementFcn = str2func(fuser.MeasurementFcn);
                end
            else
                switch lower(fuser.MeasurementFormat)
                    case 'position'
                        fuser.pMeasurementFcn = @posmeas;
                    case 'velocity'
                        fuser.pMeasurementFcn = @velmeas;
                    case 'positionandvelocity'
                        fuser.pMeasurementFcn = @cvmeas;
                        fuser.pFusedMeasParam.HasVelocity = true;
                end
            end
        end
        
        function [compositeDetections,info] = stepImpl(fuser,detections)
            % step - fuser(detections)
            
            % Get a list of detections separated by source. 
            [pDetections, globalIDs] = sortDetectionsBySource(fuser,detections);
            
            % Calculate cost matrix
            costMatrix = calcCost(fuser,pDetections);
            
            % Calculate assignments
            [assignments, globalAssignments, falseAlarmIDs] = calcAssignments(fuser,costMatrix,globalIDs);

            % Fuse measurement and measurement noise
            [meas,measCov,attribs] = fuseAssignedDetections(fuser,assignments,pDetections);
            
            % Assemble composite detections
            [compositeDetections] = assembleCompositeDetections(fuser,meas,measCov,attribs);
            
            % Assemble info
            info = struct('CostMatrix',costMatrix,'Assignments',globalAssignments, 'FalseAlarms',falseAlarmIDs);
        end
        
        function [pDetections, globalIDs] = sortDetectionsBySource(fuser,detections)
            % pDetections is a cell array of length n, where n is the
            % number of originating sensors and each element is a cell
            % array of objectDetections from that sensor.
            
            % Get detections in a cell array
            detsInCell = getDetectionsInCell(fuser,detections);
            
            % Validate time stamps are correct
            validateTimeStamps(fuser,detsInCell);
            
            % Sort by originating sensor
            originatingSensor = zeros(numel(detections),1);
            for i = 1:numel(detsInCell)
                originatingSensor(i) = detsInCell{i}.SensorIndex;
            end
           
            sensorIDs = unique(originatingSensor);
            numSensors = numel(sensorIDs);
            
            coder.internal.errorIf(numSensors < 2, 'fusion:staticDetectionFuser:expectedAtleast2Sensors');
            coder.internal.errorIf(numSensors > fuser.MaxNumSensors,'fusion:staticDetectionFuser:exceedsMaxNumSensors');
            
            pDetections = cell(numSensors,1);
            globalIDs = cell(numSensors,1);
                       
            for i = 1:numel(pDetections)
                pDetections{i} = cell(1,0);
            end
            
            for i = 1:numSensors
                theseDetections = find(originatingSensor == sensorIDs(i));
                if coder.target('MATLAB')
                    pDetections{i} = detsInCell(theseDetections);
                else
                    thisSensorDets = cell(1,0);
                    for j = 1:numel(theseDetections)
                        thisSensorDets{end+1} = detsInCell{theseDetections(j)};
                    end
                    pDetections{i} = thisSensorDets;
                end
                globalIDs{i} = theseDetections;
            end
        end
        
        
        function detsInCell = getDetectionsInCell(fuser,detections)
            % Returns a list of detections in a cell array.
            if iscell(detections)
                detsInCell = detections;
            else
                if coder.target('MATLAB')
                    numColumns = size(detections,1);
                    colOnes = ones(numColumns, 1);
                    numRows = size(detections,2);
                    rowOnes = ones(numRows, 1);
                    detsInCell = mat2cell(detections, colOnes, rowOnes);
                else
                    detsInCell = matlabshared.tracking.internal.fusion.dets2cell(detections);
                end
            end
        end
        
        function pSampleBuffer = getBufferFromInput(fuser,detections)
            pSampleBuffer = cell(fuser.MaxNumSensors,1);
            detsInCell = getDetectionsInCell(fuser,detections);
            if coder.target('MATLAB')
                sensorIDs = cellfun(@(x)x.SensorIndex,detsInCell);
            else
                sensorIDs = zeros(numel(detsInCell),1,'like',detsInCell{1}.SensorIndex);
                for i = 1:numel(detsInCell)
                    sensorIDs(i) = detsInCell{i}.SensorIndex;
                end
            end
            [uniqueIDs,theirIDs] = unique(sensorIDs);
            numSensors = numel(uniqueIDs);
            coder.internal.errorIf(numSensors~=fuser.MaxNumSensors,'fusion:staticDetectionFuser:UndefinedSampleBuffer');
            for i = 1:fuser.MaxNumSensors
                pSampleBuffer{i} = detsInCell{theirIDs(i)};
            end
        end

        function costMatrix = calcCost(fuser,pDetections)
            % Fuse minimum 2 sensors for a valid state estimation.
            minValidTriangulation = 2;
            
            numDetections = zeros(numel(pDetections),1,fuser.pDataType);
            sensorIDs = zeros(numel(pDetections),1,fuser.pDataType);
            
            % Collect detections from input and their lengths.
            for i = 1:numel(pDetections)
                numDetections(i) = numel(pDetections{i});
                sensorIDs(i) = pDetections{i}{1}.SensorIndex;
            end
        
            % sizeValues for cost matrix.
            sizeValues = numDetections + 1;
            
            % Possible number of associations.
            numAssociations = prod(numDetections+1); % 1 for dummy
            
            % Pre-allocate memory for outputs
            fusedStates = zeros(fuser.pStateSize,numAssociations,fuser.pDataType);
            costValues = zeros(numAssociations,1,fuser.pDataType);
            
            if coder.target('MATLAB')
                constSizeValues = sizeValues';
            else
                constSizeValues = ones(1,fuser.MaxNumSensors);
                for i = 1:numel(sizeValues)
                    constSizeValues(i) = sizeValues(i);
                end
            end
            
            % Get function handles to pass in the parfor loop to avoid
            % broadcasting the fuser.
            stateEstimationFcn = fuser.pMeasurementFusionFcn;
            measurementFcn = fuser.pMeasurementFcn;
            
            sampleBuffer = fuser.pSampleBuffer;
            
            % Get Pd, Pfa, V to pass to the parfor function.
            Pd = fuser.DetectionProbability(sensorIDs);
            Pfa = fuser.FalseAlarmRate(sensorIDs);
            V = fuser.Volume(sensorIDs);
            
            if fuser.pUseParallel
                [~,costMatrix] = fusion.internal.calcNDCostMatrixParallel(fusedStates,...
                    costValues,pDetections,stateEstimationFcn,measurementFcn,...
                    minValidTriangulation,constSizeValues,sampleBuffer,...
                    Pd,Pfa,V);
            else
                [~,costMatrix] = fusion.internal.calcNDCostMatrix(fusedStates,...
                    costValues,pDetections,stateEstimationFcn,measurementFcn,...
                    minValidTriangulation,constSizeValues,sampleBuffer,...
                    Pd,Pfa,V);
            end
        end
        
        % Calculate assignments given cost matrix.
        function [assignments, globalAssignments, falseAlarmIDs] = calcAssignments(fuser,costMatrix,globalIDs)
            if numel(size(costMatrix)) == 2
                assignments = fuser.p2DAssignmentFcn(costMatrix);
                % The internal 2-D assignment function always returns a
                % dummy assignment on top. We can remove it safely.
                assignments = assignments(2:end,:);
            else
                assignments = fuser.pSDAssignmentFcn(costMatrix);
            end
            globalAssignments = assignments(:,1:numel(globalIDs));
            for i = 1:numel(globalIDs)
                thisIndex = globalAssignments(:,i) - 1;
                validIndex = thisIndex > 0;
                getIndex = thisIndex(validIndex);
                globalAssignments(validIndex,i) = (globalIDs{i}(getIndex));
                globalAssignments(~validIndex,i) = 0;
            end
            numAssignments = sum(globalAssignments > 0,2);
            falseIDs = numAssignments == 1;
            falseAssociations = sum(globalAssignments(falseIDs,:),2);
            globalAssignments = globalAssignments(~falseIDs,:);
            falseAlarmIDs = uint32(falseAssociations);
            if ~coder.target('MATLAB')
                globalAssignments(:,numel(globalIDs)+1:end) = 0;
            end
        end

        function [compositeDets] = assembleCompositeDetections(fuser,meas,measCov,attribs)
            time = fuser.pDetectionTime;
            compositeDets = cell(1,0);
            for i = 1:size(meas,2)
                measurement = meas(:,i);
                measurementCov = measCov(:,:,i);
                compositeDets{end+1} = objectDetection(time,measurement(:),...
                    'MeasurementNoise',measurementCov,...
                    'MeasurementParameters',fuser.pFusedMeasParam,...
                    'SensorIndex',fuser.FusedSensorIndex,...
                    'ObjectAttributes',{attribs{i}});
            end
        end
        
        function [meas,measCov,fusedAttribs] = fuseAssignedDetections(fuser,assignments,pDetections)
            
            if isa(pDetections{1}{1},'objectDetection') || isfield(pDetections{1}{1},'ObjectAttributes')
                if iscell(pDetections{1}{1}.ObjectAttributes) && ~isempty(pDetections{1}{1}.ObjectAttributes)
                    thisFusedAttribute = repmat(pDetections{1}{1}.ObjectAttributes{1},[fuser.MaxNumSensors 1]);
                    fuseAttributes = true;
                    retrieveMethod = uint32(1);
                elseif isstruct(pDetections{1}{1}.ObjectAttributes)
                    thisFusedAttribute = repmat(pDetections{1}{1}.ObjectAttributes,[fuser.MaxNumSensors 1]);
                    fuseAttributes = true;
                    retrieveMethod = uint32(2);
                else
                    thisFusedAttribute = struct;
                    fuseAttributes = false;
                    retrieveMethod = uint32(0);
                end
            else
                retrieveMethod = uint32(0);
                thisFusedAttribute = struct;
                fuseAttributes = false;
            end
            
            numMeas = size(assignments,1);
            meas = NaN(fuser.pStateSize,numMeas);
            measCov = NaN(fuser.pStateSize,fuser.pStateSize,numMeas);
            attribs = repmat({thisFusedAttribute},[numMeas 1]);
            numSensors = numel(pDetections);
            for i = 1:numMeas
                if coder.target('MATLAB')
                    argsIn = num2cell(assignments(i,:));
                else
                    argsIn = cell(numSensors,1);
                    for j = 1:numel(argsIn)
                        argsIn{j} = assignments(i,j);
                    end
                end
                thisBuffer = cell(1,0);
                for k = 1:numel(pDetections)
                    if argsIn{k} > 1
                        thisBuffer{end+1} = pDetections{k}{argsIn{k} - 1};
                    end
                end
                if numel(thisBuffer) >= 2
                    [meas(:,i),measCov(:,:,i)] = fuser.pMeasurementFusionFcn(thisBuffer);
                end
                
                % Attribute fusion. Just concatenate all ObjectAttributes.                
                if fuseAttributes
                    for k = 1:numel(thisBuffer)
                        if retrieveMethod ==  1
                            thisFusedAttribute(k) = thisBuffer{k}.ObjectAttributes{1};
                        else
                            thisFusedAttribute(k) = thisBuffer{k}.ObjectAttributes;
                        end
                    end
                end
                attribs{i} = thisFusedAttribute;
            end
            availableIndices = ~isnan(meas(1,:));
            meas = meas(:,availableIndices);
            measCov = measCov(:,:,availableIndices);
            if coder.target('MATLAB')
                fusedAttribs = {attribs{availableIndices}};
            else
                fusedAttribs = cell(1,0);
                for i = 1:numel(attribs)
                    if availableIndices(i)
                        fusedAttribs{end+1} = attribs{i};
                    end
                end
            end
        end
        
        function flag = isInactivePropertyImpl(fuser,prop)
            flag = false;
            if strcmpi(prop,'MeasurementFcn') && ~strcmpi(fuser.MeasurementFormat,'Custom')
                flag = true;
            end
        end
        
        function validateTimeStamps(fuser,detsInCell)
           % Validate time stamps and set the fuser's current detection time. 
           measTime = detsInCell{1}.Time;
           
           if coder.target('MATLAB')
               % It's easy to get time stamps in MATLAB and then do a
               % comparison.
               timeStamps = cellfun(@(x)x.Time,detsInCell);
               errorCond = any(abs(timeStamps - measTime) > fuser.pTimeTolerance);
               coder.internal.errorIf(errorCond,'fusion:staticDetectionFuser:expectedTimeStampsWithinTolerance');
           else
               % In coder, do a step by step comparison and fail when
               % invalid.
               for i = 1:numel(detsInCell)
                   thisTimeStamp = detsInCell{i}.Time;
                   condError = abs(thisTimeStamp - measTime) > fuser.pTimeTolerance;
                   coder.internal.errorIf(condError,'fusion:staticDetectionFuser:expectedTimeStampsWithinTolerance');
               end
           end
           fuser.pDetectionTime = measTime;
        end
        
        function loadObjectImpl(obj,s,wasLocked)
            % Set properties in object obj to values in structure s
 
            % Set private and protected properties
            obj.pStateSize = s.pStateSize;
            obj.pDataType = s.pDataType;
            obj.p2DAssignmentFcn = s.p2DAssignmentFcn;
            obj.pSDAssignmentFcn = s.pSDAssignmentFcn;
            obj.pMeasurementFcn = s.pMeasurementFcn;
            obj.pMeasurementFusionFcn = s.pMeasurementFusionFcn;
            obj.pTimeTolerance = s.pTimeTolerance;
            obj.pSampleBuffer = s.pSampleBuffer;
            obj.pDetectionProbability = s.pDetectionProbability;
            obj.pVolume = s.pVolume;
            obj.pFalseAlarmRate = s.pFalseAlarmRate;
            obj.pDetectionTime = s.pDetectionTime;
            obj.pFusedMeasParam = s.pFusedMeasParam;
 
            % Set public properties and states
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
        
        function s = saveObjectImpl(obj)
            % Set properties in structure s to values in object obj
 
            % Set public properties and states
            s = saveObjectImpl@matlab.System(obj);
 
            % Set private and protected properties
            s.pStateSize = obj.pStateSize;
            s.pDataType = obj.pDataType;
            s.p2DAssignmentFcn = obj.p2DAssignmentFcn;
            s.pSDAssignmentFcn = obj.pSDAssignmentFcn;
            s.pMeasurementFcn = obj.pMeasurementFcn;
            s.pMeasurementFusionFcn = obj.pMeasurementFusionFcn;
            s.pTimeTolerance = obj.pTimeTolerance;
            s.pSampleBuffer = obj.pSampleBuffer;
            s.pDetectionProbability = obj.pDetectionProbability;
            s.pVolume = obj.pVolume;
            s.pFalseAlarmRate = obj.pFalseAlarmRate;
            s.pDetectionTime = obj.pDetectionTime;
            s.pFusedMeasParam = obj.pFusedMeasParam;
        end

        function flag = isInputSizeMutableImpl(~, ~)
            flag = true;
        end

        function groups = getPropertyGroups(~)
            stateEstimatorGroup = matlab.mixin.util.PropertyGroup(...
                {'FusedSensorIndex','MeasurementFusionFcn','MeasurementFormat','MeasurementFcn','MeasurementJacobianFcn'});
            
            sensorPropertyGroup = matlab.mixin.util.PropertyGroup(...
                {'MaxNumSensors','Volume','DetectionProbability','FalseAlarmRate'});
            
            parallelGroup = matlab.mixin.util.PropertyGroup(...
                {'TimeTolerance','UseParallel'});
            
            groups = [stateEstimatorGroup sensorPropertyGroup parallelGroup];
        end
    end
        
    methods(Static, Hidden)    
        function flag = isAllowedInSystemBlock
            flag = false;
        end
    end
end
