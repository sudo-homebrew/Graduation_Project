
classdef EndEffectorState < ros.Message
    %EndEffectorState MATLAB implementation of baxter_core_msgs/EndEffectorState
    %   This class was automatically generated by
    %   ros.internal.pubsubEmitter.

    %   Copyright 2014-2020 The MathWorks, Inc.
    properties (Constant)
        MessageType = 'baxter_core_msgs/EndEffectorState' % The ROS message type
    end
    properties (Constant, Hidden)
        MD5Checksum = 'ade777f069d738595bc19e246b8ec7a0' % The MD5 Checksum of the message definition
        PropertyList = { 'Timestamp' 'Id' 'Enabled' 'Calibrated' 'Ready' 'Moving' 'Gripping' 'Missed' 'Error' 'Reverse' 'Position' 'Force' 'State' 'Command' 'CommandSender' 'CommandSequence' } % List of non-constant message properties
        ROSPropertyList = { 'timestamp' 'id' 'enabled' 'calibrated' 'ready' 'moving' 'gripping' 'missed' 'error' 'reverse' 'position' 'force' 'state' 'command' 'command_sender' 'command_sequence' } % List of non-constant ROS message properties
        PropertyMessageTypes = { 'ros.msg.Time' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            '' ...
            } % Types of contained nested messages
    end
    properties (Constant)
        STATEFALSE = uint8(0)
        STATETRUE = uint8(1)
        STATEUNKNOWN = uint8(2)
        POSITIONCLOSED = single(0)
        POSITIONOPEN = single(100)
        FORCEMIN = single(0)
        FORCEMAX = single(100)
    end
    properties
        Timestamp
        Id
        Enabled
        Calibrated
        Ready
        Moving
        Gripping
        Missed
        Error
        Reverse
        Position
        Force
        State
        Command
        CommandSender
        CommandSequence
    end
    methods
        function set.Timestamp(obj, val)
            validAttributes = {'nonempty', 'scalar'};
            validClasses = {'ros.msg.Time'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Timestamp')
            obj.Timestamp = val;
        end
        function set.Id(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Id');
            obj.Id = uint32(val);
        end
        function set.Enabled(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Enabled');
            obj.Enabled = uint8(val);
        end
        function set.Calibrated(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Calibrated');
            obj.Calibrated = uint8(val);
        end
        function set.Ready(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Ready');
            obj.Ready = uint8(val);
        end
        function set.Moving(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Moving');
            obj.Moving = uint8(val);
        end
        function set.Gripping(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Gripping');
            obj.Gripping = uint8(val);
        end
        function set.Missed(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Missed');
            obj.Missed = uint8(val);
        end
        function set.Error(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Error');
            obj.Error = uint8(val);
        end
        function set.Reverse(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Reverse');
            obj.Reverse = uint8(val);
        end
        function set.Position(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Position');
            obj.Position = single(val);
        end
        function set.Force(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Force');
            obj.Force = single(val);
        end
        function set.State(obj, val)
            val = convertStringsToChars(val);
            validClasses = {'char', 'string'};
            validAttributes = {};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'State');
            obj.State = char(val);
        end
        function set.Command(obj, val)
            val = convertStringsToChars(val);
            validClasses = {'char', 'string'};
            validAttributes = {};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'Command');
            obj.Command = char(val);
        end
        function set.CommandSender(obj, val)
            val = convertStringsToChars(val);
            validClasses = {'char', 'string'};
            validAttributes = {};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'CommandSender');
            obj.CommandSender = char(val);
        end
        function set.CommandSequence(obj, val)
            validClasses = {'numeric'};
            validAttributes = {'nonempty', 'scalar'};
            validateattributes(val, validClasses, validAttributes, 'EndEffectorState', 'CommandSequence');
            obj.CommandSequence = uint32(val);
        end
    end
    methods (Static, Access = {?matlab.unittest.TestCase, ?ros.Message})
        function obj = loadobj(strObj)
        %loadobj Implements loading of message from MAT file
        % Return an empty object array if the structure element is not defined
            if isempty(strObj)
                obj = ros.msggen.baxter_core_msgs.EndEffectorState.empty(0,1);
                return
            end
            % Create an empty message object
            obj = ros.msggen.baxter_core_msgs.EndEffectorState(strObj);
        end
    end
end
