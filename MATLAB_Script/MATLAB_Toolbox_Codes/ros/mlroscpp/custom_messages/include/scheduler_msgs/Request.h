// Generated by gencpp from file scheduler_msgs/Request.msg
// DO NOT EDIT!


#ifndef SCHEDULER_MSGS_MESSAGE_REQUEST_H
#define SCHEDULER_MSGS_MESSAGE_REQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <uuid_msgs/UniqueID.h>
#include <scheduler_msgs/Resource.h>

namespace scheduler_msgs
{
template <class ContainerAllocator>
struct Request_
{
  typedef Request_<ContainerAllocator> Type;

  Request_()
    : id()
    , resources()
    , status(0)
    , reason(0)
    , problem()
    , availability()
    , hold_time()
    , priority(0)  {
    }
  Request_(const ContainerAllocator& _alloc)
    : id(_alloc)
    , resources(_alloc)
    , status(0)
    , reason(0)
    , problem(_alloc)
    , availability()
    , hold_time()
    , priority(0)  {
  (void)_alloc;
    }



   typedef  ::uuid_msgs::UniqueID_<ContainerAllocator>  _id_type;
  _id_type id;

   typedef std::vector< ::scheduler_msgs::Resource_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::scheduler_msgs::Resource_<ContainerAllocator> >::other >  _resources_type;
  _resources_type resources;

   typedef uint8_t _status_type;
  _status_type status;

   typedef uint8_t _reason_type;
  _reason_type reason;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _problem_type;
  _problem_type problem;

   typedef ros::Time _availability_type;
  _availability_type availability;

   typedef ros::Duration _hold_time_type;
  _hold_time_type hold_time;

   typedef int16_t _priority_type;
  _priority_type priority;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(NEW)
  #undef NEW
#endif
#if defined(_WIN32) && defined(RESERVED)
  #undef RESERVED
#endif
#if defined(_WIN32) && defined(WAITING)
  #undef WAITING
#endif
#if defined(_WIN32) && defined(GRANTED)
  #undef GRANTED
#endif
#if defined(_WIN32) && defined(PREEMPTING)
  #undef PREEMPTING
#endif
#if defined(_WIN32) && defined(CANCELING)
  #undef CANCELING
#endif
#if defined(_WIN32) && defined(CLOSED)
  #undef CLOSED
#endif
#if defined(_WIN32) && defined(NONE)
  #undef NONE
#endif
#if defined(_WIN32) && defined(PREEMPTED)
  #undef PREEMPTED
#endif
#if defined(_WIN32) && defined(BUSY)
  #undef BUSY
#endif
#if defined(_WIN32) && defined(UNAVAILABLE)
  #undef UNAVAILABLE
#endif
#if defined(_WIN32) && defined(TIMEOUT)
  #undef TIMEOUT
#endif
#if defined(_WIN32) && defined(INVALID)
  #undef INVALID
#endif
#if defined(_WIN32) && defined(BACKGROUND_PRIORITY)
  #undef BACKGROUND_PRIORITY
#endif
#if defined(_WIN32) && defined(LOW_PRIORITY)
  #undef LOW_PRIORITY
#endif
#if defined(_WIN32) && defined(DEFAULT_PRIORITY)
  #undef DEFAULT_PRIORITY
#endif
#if defined(_WIN32) && defined(HIGH_PRIORITY)
  #undef HIGH_PRIORITY
#endif
#if defined(_WIN32) && defined(CRITICAL_PRIORITY)
  #undef CRITICAL_PRIORITY
#endif

  enum {
    NEW = 0u,
    RESERVED = 1u,
    WAITING = 2u,
    GRANTED = 3u,
    PREEMPTING = 4u,
    CANCELING = 5u,
    CLOSED = 6u,
    NONE = 0u,
    PREEMPTED = 1u,
    BUSY = 2u,
    UNAVAILABLE = 3u,
    TIMEOUT = 4u,
    INVALID = 5u,
    BACKGROUND_PRIORITY = -20000,
    LOW_PRIORITY = -10000,
    DEFAULT_PRIORITY = 0,
    HIGH_PRIORITY = 10000,
    CRITICAL_PRIORITY = 20000,
  };


  typedef boost::shared_ptr< ::scheduler_msgs::Request_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::scheduler_msgs::Request_<ContainerAllocator> const> ConstPtr;

}; // struct Request_

typedef ::scheduler_msgs::Request_<std::allocator<void> > Request;

typedef boost::shared_ptr< ::scheduler_msgs::Request > RequestPtr;
typedef boost::shared_ptr< ::scheduler_msgs::Request const> RequestConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::scheduler_msgs::Request_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::scheduler_msgs::Request_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::scheduler_msgs::Request_<ContainerAllocator1> & lhs, const ::scheduler_msgs::Request_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.resources == rhs.resources &&
    lhs.status == rhs.status &&
    lhs.reason == rhs.reason &&
    lhs.problem == rhs.problem &&
    lhs.availability == rhs.availability &&
    lhs.hold_time == rhs.hold_time &&
    lhs.priority == rhs.priority;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::scheduler_msgs::Request_<ContainerAllocator1> & lhs, const ::scheduler_msgs::Request_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace scheduler_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::scheduler_msgs::Request_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::scheduler_msgs::Request_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::scheduler_msgs::Request_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::scheduler_msgs::Request_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::scheduler_msgs::Request_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::scheduler_msgs::Request_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::scheduler_msgs::Request_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1556d9f8919617c2f52b2a4ab15f6468";
  }

  static const char* value(const ::scheduler_msgs::Request_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1556d9f8919617c2ULL;
  static const uint64_t static_value2 = 0xf52b2a4ab15f6468ULL;
};

template<class ContainerAllocator>
struct DataType< ::scheduler_msgs::Request_<ContainerAllocator> >
{
  static const char* value()
  {
    return "scheduler_msgs/Request";
  }

  static const char* value(const ::scheduler_msgs::Request_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::scheduler_msgs::Request_<ContainerAllocator> >
{
  static const char* value()
  {
    return "### Resource request description\n"
"#\n"
"#   This tracks the progress of a single requested resource group.\n"
"#   All these resources will be granted, preempted or canceled\n"
"#   together as a unit.\n"
"\n"
"##############################################################################\n"
"# Resource Identification\n"
"##############################################################################\n"
"\n"
"uuid_msgs/UniqueID id   # Requester-assigned universally unique identifier\n"
"Resource[] resources    # List of requested rapps and platforms\n"
"\n"
"##############################################################################\n"
"# State\n"
"##############################################################################\n"
"\n"
"uint8 status            # Current status of this request\n"
"uint8 reason            # Reason for this status\n"
"string problem          # Convenience message for introspecting on the reason \n"
"\n"
"#  Status value labels:\n"
"uint8 NEW         = 0   # New request for the scheduler\n"
"uint8 RESERVED    = 1   # Request for a reservation at some future time\n"
"uint8 WAITING     = 2   # Request has been queued by the scheduler\n"
"uint8 GRANTED     = 3   # Request was granted by the scheduler\n"
"uint8 PREEMPTING  = 4   # The scheduler wants to preempt this\n"
"                        #   previously-granted request, but the\n"
"                        #   requester has not yet canceled it\n"
"uint8 CANCELING   = 5   # The requester wishes to cancel this\n"
"                        #   request, but the scheduler has not yet\n"
"                        #   confirmed that it is closed\n"
"uint8 CLOSED      = 6   # Request is now closed (terminal state)\n"
"\n"
"# Reason labels:\n"
"uint8 NONE        = 0   # No reason provided\n"
"uint8 PREEMPTED   = 1   # Preempted for higher-priority task\n"
"uint8 BUSY        = 2   # Requested resource busy elsewhere\n"
"uint8 UNAVAILABLE = 3   # Requested resource not available\n"
"uint8 TIMEOUT     = 4   # Lost contact with requester\n"
"uint8 INVALID     = 5   # Ill-formed request: see problem string for details\n"
"\n"
"##############################################################################\n"
"# Scheduling Variables\n"
"##############################################################################\n"
"\n"
"time     availability   # Estimated time of availability (zero if unknown)\n"
"duration hold_time      # Estimated hold time once allocated (zero if unknown)\n"
"int16    priority       # Current priority of this request\n"
"\n"
"# Priority labels:\n"
"int16 BACKGROUND_PRIORITY = -20000      # When nothing else to do\n"
"int16 LOW_PRIORITY = -10000             # Low-priority task\n"
"int16 DEFAULT_PRIORITY = 0              # Sane default priority\n"
"int16 HIGH_PRIORITY = 10000             # High-priority task\n"
"int16 CRITICAL_PRIORITY = 20000         # Mission-critical task\n"
"\n"
"================================================================================\n"
"MSG: uuid_msgs/UniqueID\n"
"# A universally unique identifier (UUID).\n"
"#\n"
"#  http://en.wikipedia.org/wiki/Universally_unique_identifier\n"
"#  http://tools.ietf.org/html/rfc4122.html\n"
"\n"
"uint8[16] uuid\n"
"\n"
"================================================================================\n"
"MSG: scheduler_msgs/Resource\n"
"### ROCON resource request or response.\n"
"#\n"
"#   A scheduler_msgs/Request message includes one Resource message for\n"
"#   each desired resource.  The scheduler responds using this same\n"
"#   message to identify exactly what corresponding resource it has\n"
"#   granted.\n"
"\n"
"# This is usually a uniquely identifying ros_package/rapp name\n"
"# identifier, which is unique because ros packages are unique.\n"
"string rapp\n"
"\n"
"# Unique identifier assigned by the requester to track resources\n"
"# assigned in the scheduler feedback.\n"
"uuid_msgs/UniqueID id\n"
"\n"
"# Uniform Resource Identifier for the platform.  ROCON defines two\n"
"# kinds of URI strings:\n"
"#\n"
"# 1) A \"resource description URI\" is a canonical string for a specific\n"
"#    device.  All components are fully resolved to their most specific\n"
"#    values, like:\n"
"#\n"
"#      \"rocon:/turtlebot/dude3/hydro/precise\"\n"
"#\n"
"#    The scheduler provides fully resolved resource description URIs\n"
"#    in its feedback for requests that have been granted.\n"
"#\n"
"# 2) A \"request URI\" may provide a similar descriptive representation,\n"
"#    or may include patterns for matching multiple alternative\n"
"#    platforms.  Omitted or '*' patterns match any valid value:\n"
"#\n"
"#      \"\"                               # (empty string): any platform\n"
"#      \"rocon:/turtlebot\"               # any turtlebot\n"
"#      \"rocon:/(turtlebot|segbot)\"      # any robot of either type\n"
"#      \"rocon:/*/dude3\"                 # any device named dude3\n"
"#      \"rocon:/*/*/ros/ubuntu\"          # any ROS Ubuntu platform\n"
"#\n"
"string uri\n"
"\n"
"# Remappings which get passed on for starting the rapps. Also potentially for\n"
"# more esoteric use cases such as checking whether an app is sharable.\n"
"rocon_std_msgs/Remapping[] remappings\n"
"rocon_std_msgs/KeyValue[] parameters\n"
"\n"
"================================================================================\n"
"MSG: rocon_std_msgs/Remapping\n"
"# Describes your typical ros remapping\n"
"\n"
"string remap_from\n"
"string remap_to\n"
"\n"
"================================================================================\n"
"MSG: rocon_std_msgs/KeyValue\n"
"string key\n"
"string value\n"
;
  }

  static const char* value(const ::scheduler_msgs::Request_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::scheduler_msgs::Request_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.resources);
      stream.next(m.status);
      stream.next(m.reason);
      stream.next(m.problem);
      stream.next(m.availability);
      stream.next(m.hold_time);
      stream.next(m.priority);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Request_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::scheduler_msgs::Request_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::scheduler_msgs::Request_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    s << std::endl;
    Printer< ::uuid_msgs::UniqueID_<ContainerAllocator> >::stream(s, indent + "  ", v.id);
    s << indent << "resources[]" << std::endl;
    for (size_t i = 0; i < v.resources.size(); ++i)
    {
      s << indent << "  resources[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::scheduler_msgs::Resource_<ContainerAllocator> >::stream(s, indent + "    ", v.resources[i]);
    }
    s << indent << "status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status);
    s << indent << "reason: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reason);
    s << indent << "problem: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.problem);
    s << indent << "availability: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.availability);
    s << indent << "hold_time: ";
    Printer<ros::Duration>::stream(s, indent + "  ", v.hold_time);
    s << indent << "priority: ";
    Printer<int16_t>::stream(s, indent + "  ", v.priority);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SCHEDULER_MSGS_MESSAGE_REQUEST_H
