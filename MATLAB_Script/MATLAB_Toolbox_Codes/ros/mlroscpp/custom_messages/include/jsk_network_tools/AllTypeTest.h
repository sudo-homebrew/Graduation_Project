// Generated by gencpp from file jsk_network_tools/AllTypeTest.msg
// DO NOT EDIT!


#ifndef JSK_NETWORK_TOOLS_MESSAGE_ALLTYPETEST_H
#define JSK_NETWORK_TOOLS_MESSAGE_ALLTYPETEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace jsk_network_tools
{
template <class ContainerAllocator>
struct AllTypeTest_
{
  typedef AllTypeTest_<ContainerAllocator> Type;

  AllTypeTest_()
    : bool_atom(false)
    , bool_array()
    , uint8_atom(0)
    , uint8_array()
    , int8_atom(0)
    , int8_array()
    , uint16_atom(0)
    , uint16_array()
    , int32_atom(0)
    , int32_array()
    , uint32_atom(0)
    , uint32_array()
    , int64_atom(0)
    , int64_array()
    , uint64_atom(0)
    , uint64_array()
    , float32_atom(0.0)
    , float32_array()
    , float64_atom(0.0)
    , float64_array()  {
      bool_array.assign(false);

      uint8_array.assign(0);

      int8_array.assign(0);

      uint16_array.assign(0);

      int32_array.assign(0);

      uint32_array.assign(0);

      int64_array.assign(0);

      uint64_array.assign(0);

      float32_array.assign(0.0);

      float64_array.assign(0.0);
  }
  AllTypeTest_(const ContainerAllocator& _alloc)
    : bool_atom(false)
    , bool_array()
    , uint8_atom(0)
    , uint8_array()
    , int8_atom(0)
    , int8_array()
    , uint16_atom(0)
    , uint16_array()
    , int32_atom(0)
    , int32_array()
    , uint32_atom(0)
    , uint32_array()
    , int64_atom(0)
    , int64_array()
    , uint64_atom(0)
    , uint64_array()
    , float32_atom(0.0)
    , float32_array()
    , float64_atom(0.0)
    , float64_array()  {
  (void)_alloc;
      bool_array.assign(false);

      uint8_array.assign(0);

      int8_array.assign(0);

      uint16_array.assign(0);

      int32_array.assign(0);

      uint32_array.assign(0);

      int64_array.assign(0);

      uint64_array.assign(0);

      float32_array.assign(0.0);

      float64_array.assign(0.0);
  }



   typedef uint8_t _bool_atom_type;
  _bool_atom_type bool_atom;

   typedef boost::array<uint8_t, 4>  _bool_array_type;
  _bool_array_type bool_array;

   typedef uint8_t _uint8_atom_type;
  _uint8_atom_type uint8_atom;

   typedef boost::array<uint8_t, 4>  _uint8_array_type;
  _uint8_array_type uint8_array;

   typedef int8_t _int8_atom_type;
  _int8_atom_type int8_atom;

   typedef boost::array<int8_t, 4>  _int8_array_type;
  _int8_array_type int8_array;

   typedef uint16_t _uint16_atom_type;
  _uint16_atom_type uint16_atom;

   typedef boost::array<uint16_t, 4>  _uint16_array_type;
  _uint16_array_type uint16_array;

   typedef int32_t _int32_atom_type;
  _int32_atom_type int32_atom;

   typedef boost::array<int32_t, 4>  _int32_array_type;
  _int32_array_type int32_array;

   typedef uint32_t _uint32_atom_type;
  _uint32_atom_type uint32_atom;

   typedef boost::array<uint32_t, 4>  _uint32_array_type;
  _uint32_array_type uint32_array;

   typedef int64_t _int64_atom_type;
  _int64_atom_type int64_atom;

   typedef boost::array<int64_t, 4>  _int64_array_type;
  _int64_array_type int64_array;

   typedef uint64_t _uint64_atom_type;
  _uint64_atom_type uint64_atom;

   typedef boost::array<uint64_t, 4>  _uint64_array_type;
  _uint64_array_type uint64_array;

   typedef float _float32_atom_type;
  _float32_atom_type float32_atom;

   typedef boost::array<float, 4>  _float32_array_type;
  _float32_array_type float32_array;

   typedef double _float64_atom_type;
  _float64_atom_type float64_atom;

   typedef boost::array<double, 4>  _float64_array_type;
  _float64_array_type float64_array;





  typedef boost::shared_ptr< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> const> ConstPtr;

}; // struct AllTypeTest_

typedef ::jsk_network_tools::AllTypeTest_<std::allocator<void> > AllTypeTest;

typedef boost::shared_ptr< ::jsk_network_tools::AllTypeTest > AllTypeTestPtr;
typedef boost::shared_ptr< ::jsk_network_tools::AllTypeTest const> AllTypeTestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::jsk_network_tools::AllTypeTest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::jsk_network_tools::AllTypeTest_<ContainerAllocator1> & lhs, const ::jsk_network_tools::AllTypeTest_<ContainerAllocator2> & rhs)
{
  return lhs.bool_atom == rhs.bool_atom &&
    lhs.bool_array == rhs.bool_array &&
    lhs.uint8_atom == rhs.uint8_atom &&
    lhs.uint8_array == rhs.uint8_array &&
    lhs.int8_atom == rhs.int8_atom &&
    lhs.int8_array == rhs.int8_array &&
    lhs.uint16_atom == rhs.uint16_atom &&
    lhs.uint16_array == rhs.uint16_array &&
    lhs.int32_atom == rhs.int32_atom &&
    lhs.int32_array == rhs.int32_array &&
    lhs.uint32_atom == rhs.uint32_atom &&
    lhs.uint32_array == rhs.uint32_array &&
    lhs.int64_atom == rhs.int64_atom &&
    lhs.int64_array == rhs.int64_array &&
    lhs.uint64_atom == rhs.uint64_atom &&
    lhs.uint64_array == rhs.uint64_array &&
    lhs.float32_atom == rhs.float32_atom &&
    lhs.float32_array == rhs.float32_array &&
    lhs.float64_atom == rhs.float64_atom &&
    lhs.float64_array == rhs.float64_array;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::jsk_network_tools::AllTypeTest_<ContainerAllocator1> & lhs, const ::jsk_network_tools::AllTypeTest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace jsk_network_tools

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e38fde731d43d6674bf0d48497971fd6";
  }

  static const char* value(const ::jsk_network_tools::AllTypeTest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe38fde731d43d667ULL;
  static const uint64_t static_value2 = 0x4bf0d48497971fd6ULL;
};

template<class ContainerAllocator>
struct DataType< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "jsk_network_tools/AllTypeTest";
  }

  static const char* value(const ::jsk_network_tools::AllTypeTest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool       bool_atom\n"
"bool[4]    bool_array\n"
"uint8      uint8_atom\n"
"uint8[4]   uint8_array\n"
"int8       int8_atom\n"
"int8[4]    int8_array\n"
"uint16     uint16_atom\n"
"uint16[4]  uint16_array\n"
"int32      int32_atom\n"
"int32[4]   int32_array\n"
"uint32     uint32_atom\n"
"uint32[4]  uint32_array\n"
"int64      int64_atom\n"
"int64[4]   int64_array\n"
"uint64     uint64_atom\n"
"uint64[4]  uint64_array\n"
"float32    float32_atom\n"
"float32[4] float32_array\n"
"float64    float64_atom\n"
"float64[4] float64_array\n"
"\n"
"# int8, not supported\n"
"# string, not supported\n"
"# time, not supported\n"
"# duration, not supported\n"
;
  }

  static const char* value(const ::jsk_network_tools::AllTypeTest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.bool_atom);
      stream.next(m.bool_array);
      stream.next(m.uint8_atom);
      stream.next(m.uint8_array);
      stream.next(m.int8_atom);
      stream.next(m.int8_array);
      stream.next(m.uint16_atom);
      stream.next(m.uint16_array);
      stream.next(m.int32_atom);
      stream.next(m.int32_array);
      stream.next(m.uint32_atom);
      stream.next(m.uint32_array);
      stream.next(m.int64_atom);
      stream.next(m.int64_array);
      stream.next(m.uint64_atom);
      stream.next(m.uint64_array);
      stream.next(m.float32_atom);
      stream.next(m.float32_array);
      stream.next(m.float64_atom);
      stream.next(m.float64_array);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct AllTypeTest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::jsk_network_tools::AllTypeTest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::jsk_network_tools::AllTypeTest_<ContainerAllocator>& v)
  {
    s << indent << "bool_atom: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bool_atom);
    s << indent << "bool_array[]" << std::endl;
    for (size_t i = 0; i < v.bool_array.size(); ++i)
    {
      s << indent << "  bool_array[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.bool_array[i]);
    }
    s << indent << "uint8_atom: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.uint8_atom);
    s << indent << "uint8_array[]" << std::endl;
    for (size_t i = 0; i < v.uint8_array.size(); ++i)
    {
      s << indent << "  uint8_array[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.uint8_array[i]);
    }
    s << indent << "int8_atom: ";
    Printer<int8_t>::stream(s, indent + "  ", v.int8_atom);
    s << indent << "int8_array[]" << std::endl;
    for (size_t i = 0; i < v.int8_array.size(); ++i)
    {
      s << indent << "  int8_array[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.int8_array[i]);
    }
    s << indent << "uint16_atom: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.uint16_atom);
    s << indent << "uint16_array[]" << std::endl;
    for (size_t i = 0; i < v.uint16_array.size(); ++i)
    {
      s << indent << "  uint16_array[" << i << "]: ";
      Printer<uint16_t>::stream(s, indent + "  ", v.uint16_array[i]);
    }
    s << indent << "int32_atom: ";
    Printer<int32_t>::stream(s, indent + "  ", v.int32_atom);
    s << indent << "int32_array[]" << std::endl;
    for (size_t i = 0; i < v.int32_array.size(); ++i)
    {
      s << indent << "  int32_array[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.int32_array[i]);
    }
    s << indent << "uint32_atom: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.uint32_atom);
    s << indent << "uint32_array[]" << std::endl;
    for (size_t i = 0; i < v.uint32_array.size(); ++i)
    {
      s << indent << "  uint32_array[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.uint32_array[i]);
    }
    s << indent << "int64_atom: ";
    Printer<int64_t>::stream(s, indent + "  ", v.int64_atom);
    s << indent << "int64_array[]" << std::endl;
    for (size_t i = 0; i < v.int64_array.size(); ++i)
    {
      s << indent << "  int64_array[" << i << "]: ";
      Printer<int64_t>::stream(s, indent + "  ", v.int64_array[i]);
    }
    s << indent << "uint64_atom: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.uint64_atom);
    s << indent << "uint64_array[]" << std::endl;
    for (size_t i = 0; i < v.uint64_array.size(); ++i)
    {
      s << indent << "  uint64_array[" << i << "]: ";
      Printer<uint64_t>::stream(s, indent + "  ", v.uint64_array[i]);
    }
    s << indent << "float32_atom: ";
    Printer<float>::stream(s, indent + "  ", v.float32_atom);
    s << indent << "float32_array[]" << std::endl;
    for (size_t i = 0; i < v.float32_array.size(); ++i)
    {
      s << indent << "  float32_array[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.float32_array[i]);
    }
    s << indent << "float64_atom: ";
    Printer<double>::stream(s, indent + "  ", v.float64_atom);
    s << indent << "float64_array[]" << std::endl;
    for (size_t i = 0; i < v.float64_array.size(); ++i)
    {
      s << indent << "  float64_array[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.float64_array[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // JSK_NETWORK_TOOLS_MESSAGE_ALLTYPETEST_H
