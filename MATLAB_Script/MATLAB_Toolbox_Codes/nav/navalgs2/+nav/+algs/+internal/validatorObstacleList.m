classdef validatorObstacleList < nav.StateValidator & ...
                                 matlabshared.planning.internal.EnforceScalarHandle & ...
                                 nav.algs.internal.InternalAccess
%VALIDATOROBSTACLELIST State validator based on discrete set of obstacles
    %   validatorObstacleList validates states and discretized motions
    %   by checking for collisions between an EgoObject and a list of
    %   obstacles. If the EgoObject is in collision with any obstacle in a
    %   given state, the state is considered invalid. Only free space is
    %   considered valid.
    %
    %   VALIDATOR = validatorObstacleList creates an obstacleList validator
    %   associated with an SE2 state space, and CollisionGeometry-based
    %   collision checking.
    %
    %   VALIDATOR = validatorObstacleList(SPACE) creates a validator in the
    %   state space, SPACE, given as an object from a class derived from
    %   nav.StateSpace. The dimensionality of the stateSpace should
    %   align with the expectations of the ObstacleList's
    %   "checkCollision" method.
    %
    %   VALIDATOR = validatorObstacleList(SPACE,Name,Value) provides additional
    %   options specified by one or more Name,Value pair arguments. You can 
    %   specify several name-value pair arguments in any order as 
    %   Name1,Value1,...,NameN,ValueN:
    %
    %       'ObstacleList'       - Sets the ObstacleList property. Must be
    %                              an object derived from the
    %                              nav.ObstacleList class.
    %
    %                              Default: obstacleListCollisionGeometry
    %
    %                              NOTE: ObstacleList type cannot be changed in
    %                              generated code after the validator is constructed. 
    %                              This name-value pair must be provided when using
    %                              non-default list types in codegen workflows.
    %
    %       'StateTransformFcn'  - Allows the user to provide a function-handle
    %                              which transforms states generated
    %                              by their StateSpace into a format
    %                              accepted by the ObstacleList. If the property
    %                              is empty, states generated by the validator's
    %                              StateSpace will be passed directly to the
    %                              ObstacleList.checkCollision during planning.
    %
    %                              Default: []
    %
    %   validatorObstacleList properties:
    %      StateSpace         - State space for validating states
    %      ObstacleList               - ObstacleList used for validating states
    %      ValidationDistance - Interval for checking state validity
    %      StateTransformFcn     - Function handle for transforming states
    %
    %   validatorObstacleList methods:
    %      copy               - Create deep copy of object
    %      isStateValid       - Check if state is valid
    %      isMotionValid      - Check if path between states is valid
    %
    %   See also validatorOccupancyMap, validatorVehicleCostmap.

    %   Copyright 2019 The MathWorks, Inc.
        
    properties
        %ObstacleList A list of obstacles that can perform collision checking against objects of the same type
        %
        %   The ObstacleList is a class that contains a list of
        %   collision-primitives used to represent the environment. The
        %   ego-object is contained in this class as the same type of
        %   collision-primitive. When isStateValid or isMotionValid are
        %   called, the ego-object is transformed by the provided states,
        %   and the ObstacleList checks to see if any collisions occur
        %   between the ego-object and the list of obstacles in the
        %   environment.
        ObstacleList
        
        %ValidationDistance Interval for checking state validity
        ValidationDistance = Inf;
        
        %StateTransformFcn Transforms states created by StateSpace to a form accepted by ObstacleList
        %
        %   STATES_T = @(STATES)StateTransformFcn(STATES) is a function-handle
        %   that accepts an N-by-M input of states, where N is the number
        %   of states and M is StateSpace.NumStateVariables, and outputs an
        %   N-by-P set of states, STATES_T, which have been converted to a form
        %   accepted by the checkCollision method of the ObstacleList. 
        %
        %   Example:
        %       v = nav.algs.internal.validatorObstacleList(...
        %            stateSpaceSE2, 'ObstacleList', nav.algs.internal.obstacleListCollisionGeometry);
        %       v.ObstacleList.addObstacle(collisionBox(2,2,2));
        %
        %       % States generated by the StateSpace are of the form [x y theta], 
        %       % which is accepted by the ObstacleList
        %       v.StateSpace.StateBounds = [-5 5; -5 5; -pi pi];
        %       se2States = v.StateSpace.sampleUniform(10)
        %       isFreeValidator    = v.isStateValid(se2States)
        %       isFreeObstacleList = v.ObstacleList.checkCollision(se2States)
        %
        %       % If the stateSpace given to the validator generates states
        %       % that are not accepted by ObstacleList.checkCollision, the
        %       % StateTransformFcn can be used to convert them to an accepted
        %       % format.
        %       badStateXYZThetaZ = [se2States(:,1:2) rand(10,1) se2States(:,3)]
        %
        %       % Try to call checkCollision with this state
        %       try
        %           isFree = v.ObstacleList.checkCollision(badStateXYZThetaZ);
        %       catch
        %           disp('No can do');
        %       end
        %
        %       % The ObstacleList accepts Nx3, Nx6, or Nx7 inputs (see 'checkCollision')
        %           % >> help nav.algs.internal.obstacleListCollisionGeometry
        %
        %       % Provide the validator with a function handle that converts
        %       % [x y z Oz] states to [x y z Ox Oy Oz].
        %       f = @(x)[x(:,1:3) zeros(size(x,1),2) x(:,4)];
        %       v.StateTransformFcn = f;
        %
        %       % Try using isStateValid with the previously unacceptable state
        %       isFree = v.isStateValid(badStateXYZThetaZ)
        %
        StateTransformFcn
    end
    
    properties (Access = {?nav.algs.internal.InternalAccess})
        
        %SkipStateValidation Skip validation in certain member functions
        %   This switch is used by internal functions only
        SkipStateValidation = false
    end
    
    methods
        function set.ObstacleList(obj, obstacleList)
        %set.ObstacleList Validates that the obstacleList input is valid
            validateattributes(obstacleList,{'nav.algs.internal.ObstacleList'},{'nonempty','scalar'},'nav.algs.internal.obstacleListCollisionGeometry','obstacleList',1);
            obj.ObstacleList = obstacleList;
        end
    end
    
    methods
        function obj = validatorObstacleList(varargin)
        %validatorObstacleList Construct a validatorObstacleList object
        
            % Parse inputs
            [stateSpace, stateTransform, obstacleList] = nav.algs.internal.validatorObstacleList.parseConstructor(varargin{:});            
            
            % Construct the base class
            obj = obj@nav.StateValidator(stateSpace);
            
            % Add the obstacleList
            obj.ObstacleList = obstacleList;
            
            % Set the StateTransformFcn handle
            obj.StateTransformFcn = stateTransform;
        end
        
        function isValid = isStateValid(obj, states)
        %isStateValid Check if state is valid
        %
        %   ISVALID = isStateValid(OBJ, STATES) verifies if a set of given states,
        %   STATES, are valid. STATES must be an N-by-NumStateVariables
        %   matrix, representing N state samples within the StateSpace property.
        %   ISVALID is an n-elment vector of logical values, with TRUE
        %   indicating that the corresponding state sample in STATES is
        %   valid.
        %
        %   Example:
        %       % Create an ObstacleList using some collision geometries
        %       oList = obstacleListCollisionGeometry;
        %       figure
        %       show(map)
        %
        %       % Create a state validator for SE2 states
        %       validator = validatorOccupancyMap
        %       validator.Map = map;
        %
        %       % State on the diagonal is invalid (occupied)
        %       isStateValid(validator, [4.5 5.5 0])
        %
        %       % States at different locations are valid (unoccupied)
        %       isStateValid(validator, [2 1 0; 3.5 4.2 0])
        %
        %       % State that is outside of map bounds is invalid
        %       isStateValid(validator, [20 15 pi])
        
            narginchk(2,2);
        
            if isempty(obj.StateTransformFcn)
                % No transform function has been implemented, provide the
                % states directly to ObstacleList's checkCollision method

                if ~obj.SkipStateValidation
                    nav.internal.validation.validateStateMatrix(states, nan, obj.StateSpace.NumStateVariables, ...
                                                                'isStateValid', 'state');
                end
                isValid = ~obj.ObstacleList.checkCollision(states);
            else
                % Use the provided transformation function to format the
                % generated states
                isValid = ~obj.ObstacleList.checkCollision(obj.StateTransformFcn(states));
            end
        end
        
        function [isValid, lastStateValid] = isMotionValid(obj, state1, state2)
        %isMotionValid Check if path between states is valid
        %   ISVALID = isMotionValid(OBJ, STATE1, STATE2) verifies if
        %   the path between STATE1 and STATE2 is valid. Both STATE1
        %   and STATE2 are vectors with length NumStateVariables.
        %   ISVALID is a logical scalar, with TRUE indicating that the
        %   given motion is valid. The start state STATE1 is assumed
        %   to be valid.
        %
        %   [ISVALID, LASTVALID] = isMotionValid(OBJ, STATE1, STATE2)
        %   also returns the last valid state, LASTVALID, if ISVALID
        %   is FALSE. LASTVALID is a state between STATE1 and STATE2. If
        %   STATE1 is invalid, LASTVALID returns a state-vector of NaNs.
        %
        %   Example:
        %     % Create an ObstacleList from a set of simple CollisionGeometry objects
        %     % and visualize it.
        %     rng(0);
        %     egoObject = collisionBox(1,1,1);
        %     collisionObjects = {collisionBox(2,2,2), collisionCylinder(2,2), collisionSphere(2)};
        %     obstacleList = nav.algs.internal.obstacleListCollisionGeometry(egoObject, collisionObjects);
        %     show(obstacleList);
        % 
        %     % Create a state validator using an SE2 StateSpace and the obstacleList
        %     stateSpace = stateSpaceSE2;
        %     stateSpace.StateBounds = [-10 10; -10 10; -pi pi];
        %     validator = nav.algs.internal.validatorObstacleList(stateSpaceSE2, 'ObstacleList', obstacleList);
        % 
        %     % Update the poses of the obstacles in the obstacleList
        %     randomPoses = sampleUniform(stateSpace, obstacleList.NumObstacles);
        %     updateObstaclePose(obstacleList, randomPoses);
        % 
        %     % Set a validation distance at motion path should be checked
        %     validator.ValidationDistance = 0.01;
        % 
        %     % Move the obstacle between two poses and check if the
        %     % motion is valid
        %     startPose = sampleUniform(stateSpace, 1);
        %     endPose   = sampleUniform(stateSpace, 1);
        %     isValid = isMotionValid(validator, startPose, endPose)
        % 
        %     % Move the EgoObject from the center of the StateSpace the
        %     % center of the first obstacle and determine whether the motion is valid
        %     newStartPose = zeros(1, stateSpace.NumStateVariables);
        %     newEndPose   = randomPoses(1,:);
        %     newEndPose(3:end) = zeros(1,size(randomPoses,2)-2);
        %     [isValid, lastValidState] = isMotionValid(validator, newStartPose, newEndPose);
        % 
        %     % Verify the results using the ObstacleList
        %     dist = validator.StateSpace.distance(newStartPose, newEndPose);
        %     interval = validator.ValidationDistance/dist;
        %     interpolatedStates = interpolate(stateSpace, newStartPose, newEndPose, ...
        %                                    [0:interval:1 1]);
        %     checkCollision(obstacleList, interpolatedStates, true);
        
            if ~obj.SkipStateValidation
                narginchk(3,3);

                state1 = nav.internal.validation.validateStateVector(state1, ...
                                                                  obj.StateSpace.NumStateVariables, 'isMotionValid', 'state1');
                state2 = nav.internal.validation.validateStateVector(state2, ...
                                                                  obj.StateSpace.NumStateVariables, 'isMotionValid', 'state2');                
                
                % Verify that state1 is valid
                if ~obj.isStateValid(state1)
                    isValid = false;
                    lastStateValid = nan(1,obj.StateSpace.NumStateVariables);
                    return
                end
            end
        
            dist = obj.StateSpace.distance(state1, state2);
            interval = obj.ValidationDistance/dist;
            interpStates = obj.StateSpace.interpolate(state1, state2, [0:interval:1 1]);
            
            % Check all interpolated states for validity
            interpValid = obj.isStateValid(interpStates);
            isValid = all(interpValid);
            
            if nargout == 2
                % Find the first invalid index. Note that the maximum non-empty
                % value of firstInvalidIdx can be 2, since we always check
                % state1 and state2 and state1 is already verified above.

                if isValid
                    % The whole motion is valid
                    lastStateValid = state2;
                else
                    firstInvalidIdx = find(~interpValid, 1);
                    if firstInvalidIdx == 1
                        lastStateValid = nan(1,obj.StateSpace.NumStateVariables);
                    else
                        lastStateValid = interpStates(firstInvalidIdx-1,:);
                    end
                end
            end
        end
        
        function copyObj = copy(obj)
        %copy Creates a deep copy of the validator
            copyObj = nav.algs.internal.validatorObstacleList(copy(obj.StateSpace), 'ObstacleList', copy(obj.ObstacleList), 'StateTransformFcn', obj.StateTransformFcn);
            copyObj.ValidationDistance = obj.ValidationDistance;
        end
    end
    
    methods (Hidden)
        function isequal = isequaln(this,other)
        %isequaln Override the ISEQUALN method to perform a modified equality check on the StateTransformFcn property
            isequal = isequaln(this.StateSpace, other.StateSpace) & ...
                      isequaln(this.ValidationDistance, other.ValidationDistance) & ...
                      isequaln(this.ObstacleList, other.ObstacleList) & ...
                      isequaln(func2str(this.StateTransformFcn), func2str(other.StateTransformFcn));
        end
    end
    
    methods (Access = private, Static)
        function [stateSpace, stateTransform, obstacleList] = parseConstructor(varargin)
        %parseConstructor Parse inputs to the obstacleList constructor
            narginchk(0,5)
            
            p = matlabshared.autonomous.core.internal.NameValueParser({'StateTransformFcn', 'ObstacleList'},...
                {[], nav.algs.internal.obstacleListCollisionGeometry});
            
            if nargin == 0
                stateSpace = stateSpaceSE2;
                p.parse(varargin{:});
            else
                % If any inputs are provided, stateSpace must come first
                stateSpace = varargin{1};
                p.parse(varargin{2:end});
            end
            
            % Parse optional name-value pairs
            stateTransform = p.parameterValue('StateTransformFcn');
            obstacleList = p.parameterValue('ObstacleList');
        end
    end
end
